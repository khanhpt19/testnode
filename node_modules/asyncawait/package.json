{
  "_from": "asyncawait",
  "_id": "asyncawait@3.0.0",
  "_inBundle": false,
  "_integrity": "sha512-dkB1xxfmIX3smmQiZHRfgD1m9Ggm9tkT162Q9wZzhW6RLOoO3VWTgNDZ0E3UwzqoypMmz9kMxdVd9u9mh8yXlA==",
  "_location": "/asyncawait",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "asyncawait",
    "fetchSpec": "latest",
    "name": "asyncawait",
    "raw": "asyncawait",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/asyncawait/-/asyncawait-3.0.0.tgz",
  "_shasum": "845814ec6166fd72813c9c20cd05f8733e134635",
  "_shrinkwrap": null,
  "_spec": "asyncawait",
  "_where": "/home/pham.tien.khanh/Server/testnode",
  "author": {
    "email": "yortus@gmail.com",
    "name": "Troy Gerwien",
    "url": "http://github.com/yortus/"
  },
  "bugs": {
    "url": "http://github.com/yortus/asyncawait/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "bluebird": "^3.1.1",
    "fibers": "^4.0.2",
    "lodash": "^4.17.12"
  },
  "deprecated": false,
  "description": "async/await for node.js",
  "devDependencies": {
    "async": "^1.4.2",
    "asyncx": "^0.4.5",
    "chai": "^3.2.0",
    "co": "^4.6.0",
    "mocha": "^5.2.0",
    "mock-fs": "^3.1.0",
    "rewire": "^2.3.4",
    "typescript": "1.7.5"
  },
  "homepage": "https://github.com/yortus/asyncawait",
  "keywords": [
    "async",
    "async/await",
    "asynchronous",
    "await",
    "callback",
    "callback hell",
    "coffeescript",
    "control flow",
    "coroutine",
    "fiber",
    "generator",
    "pyramid of doom",
    "synchronous",
    "typescript",
    "yield"
  ],
  "license": "MIT",
  "main": "index.js",
  "name": "asyncawait",
  "optionalDependencies": {},
  "readme": "# UPDATE June 2018\n\nDo you need this library?\n\nThis library has enabled async/await coding style in Node.js since 2014. But JavaScript now has native async/await.\nJS async/await was standardized as part of ES2017, and has been enabled by default in Node.js since v7.6.\n\nSo, do you still need this library? If you are just starting to use async/await, the answer is probably no. Use native\nasync/await. If you're maintaining a codebase that uses this library, or that needs to run on a old version of Node.js,\nthen you may want to keep using it, but consider migrating to native async/await eventually. If you need deep coroutines\nfor an advanced scenario, there may still be a case for using this library, since native async/await only supports\nshallow coroutine semantics.\n\n# Guide to `asyncawait` v1.0\n1. [Introduction](#1-introduction)\n2. [Feature/Gotcha Summary](#2-featuregotcha-summary)\n3. [How Does it Work?](#3-how-does-it-work)\n4. [Compared to...](#4-compared-to)\n5. [Performance](#5-performance)\n6. [Quick Start](#6-quick-start)\n    - [Installation](#installation)\n    - [Async/Await 101](#asyncawait-101)\n    - [Basic Example](#basic-example)\n    - [More Examples](#more-examples)\n7. [`async` in Depth: Suspendable Functions](#7-async-in-depth-suspendable-functions)\n    - [Accepting Arguments and Returning Values](#accepting-arguments-and-returning-values)\n    - [Handling Errors and Exceptions](#handling-errors-and-exceptions)\n    - [Obtaining Results from Suspendable Functions](#obtaining-results-from-suspendable-functions)\n    - [Preservation of `this` Context](#preservation-of-this-context)\n    - [Creating and Using Asynchronous Iterators](#creating-and-using-asynchronous-iterators)\n    - [Eager versus Lazy Execution](#eager-versus-lazy-execution)\n    - [Nesting, Composition and Recursion](#nesting-composition-and-recursion)\n    - [The `async.mod` Function](#the-asyncmod-function)\n8. [`await` in Depth: Awaitable Expressions](#8-await-in-depth-awaitable-expressions)\n    - [What Works with `await`?](#what-works-with-await)\n    - [Obtaining Awaitable Versions of Node-Style APIs](#obtaining-awaitable-versions-of-node-style-apis)\n    - [Maximising Concurrency](#maximising-concurrency)\n    - [Variations of `await`](#variations-of-await)\n9. [Recipes](#9-recipes)\n    - [Handling HTTP Routes with Express](#handling-http-routes-with-express)\n    - [Asynchronous Testing with Mocha](#asynchronous-testing-with-mocha)\n10. [API Reference](#10-api-reference)\n11. [Acknowledgements](#11-acknowledgements)\n12. [License](#12-license)\n\n\n\n# 1. Introduction\n`asyncawait` addresses the problem of [callback hell](http://callbackhell.com/) in Node.js JavaScript code. Inspired by [C#'s async/await](http://msdn.microsoft.com/en-us/library/hh191443.aspx) feature, `asyncawait` enables you to write functions that **appear** to block at each asynchronous operation, waiting for the results before continuing with the following statement. For example, you can write the following in plain JavaScript:\n\n```javascript\nvar foo = async (function() {\n    var resultA = await (firstAsyncCall());\n    var resultB = await (secondAsyncCallUsing(resultA));\n    var resultC = await (thirdAsyncCallUsing(resultB));\n    return doSomethingWith(resultC);\n});\n```\n\nwhich, with one [proviso](#obtaining-awaitable-versions-of-node-style-apis), is semantically equivalent to:\n\n```javascript\nfunction foo2(callback) {\n    firstAsyncCall(function (err, resultA) {\n        if (err) { callback(err); return; }\n        secondAsyncCallUsing(resultA, function (err, resultB) {\n            if (err) { callback(err); return; }\n            thirdAsyncCallUsing(resultB, function (err, resultC) {\n                if (err) {\n                    callback(err);\n                } else {\n                    callback(null, doSomethingWith(resultC));\n                }\n            });\n\n        });\n    });\n}\n```\n\nThe function `foo` does not block Node's event loop, despite its synchronous appearance. Execution within `foo` is suspended during each of its three asynchronous operations, but Node's event loop can execute other code whilst those operations are pending. You can write code like the above example in a HTTP request handler, and achieve high throughput with many simultaneous connections, just like with callback-based asynchronous handlers.\n\nIn short, `asyncawait` marries the high concurrency of asynchronous code with the visual clarity and conciseness of synchronous code. Rather than passing callbacks and error-backs, you can `return` values and use `try/catch` blocks. Rather than `require`ing specialised asynchronous control-flow constructs like [`each`](https://github.com/caolan/async#eacharr-iterator-callback) and [`whilst`](https://github.com/caolan/async#whilsttest-fn-callback), you can use plain JavaScript constructs like `for` and `while` loops.\n\n\n\n# 2. Feature/Gotcha Summary\n* Eliminates callback spaghetti code.\n* Enables the use of ordinary JavaScript control flow constructs for asynchronous operations.\n* Syntax is plain JavaScript, and behaves much like C#'s async/await.\n* Seamless interoperation with most other libraries, including [Express](expressjs.com), [Mocha](http://mochajs.org/), [Underscore](http://documentcloud.github.io/underscore/), [Bluebird](https://github.com/petkaantonov/bluebird), etc.\n* [Fast](./comparison) and lightweight.\n* Completely [non-blocking](http://stackoverflow.com/a/14797359).\n* Does not require [ES6 generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*).\n* No code preprocessing or special build steps, simply write and execute your code normally.\n* Built with [node-fibers](https://github.com/laverdet/node-fibers).\n* [TypeScript](http://www.typescriptlang.org/) and X-to-JavaScript friendly (since ES6 generators are not required).\n* TypeScript typings are embedded.\n* Works only in Node.js, not in browsers (since it uses node-fibers).\n\n\n\n# 3. How does it work?\nLike [`co`](https://github.com/visionmedia/co), `asyncawait` can suspend a running function without blocking Node's event loop. Both libraries are built on [coroutines](http://en.wikipedia.org/wiki/Coroutine), but use different technologies. `co` uses [ES6 generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*), which work in Node >= v0.11.2 (with the `--harmony` flag), and will hopefully be supported someday by all popular JavaScript environments and toolchains.\n\n`asyncawait` uses [`node-fibers`](https://github.com/laverdet/node-fibers). It works with plain ES3/ES5 JavaScript, which is great if your tools do not yet support ES6 generators. This may be an important consideration when using [compile-to-JavaScript languages](https://github.com/jashkenas/coffee-script/wiki/List-of-languages-that-compile-to-JS), such as [TypeScript](http://www.typescriptlang.org/) or [CoffeeScript](http://coffeescript.org/).\n\nA similar outcome may be achieved by transforming JavaScript source code in a preprocessing step. [streamline.js](https://github.com/Sage/streamlinejs) is an example of this method. Code using `asyncawait` is executed normally without any code tranformation or preprocessing.\n\n\n\n# 4. Compared to...\n`asyncawait` represents one of several viable approaches to writing complex asynchronous code in Node.js, with its own particular trade-offs. Notable alternatives include [`async`](https://github.com/caolan/async), [`bluebird`](https://github.com/petkaantonov/bluebird/) and [`co`](https://github.com/visionmedia/co), each with their own trade-offs. The following table summarises some of the alternatives and their pros and cons. For more information about how the alternatives compare, take a look in the [comparison](./comparison) folder.\n\n`asyncawait` may be a good choice if (a) you need highly concurrent throughput, (b) your asynchronous code must be clear and concise, (c) your code targets Node.js, and (d) you are limited to ES3/ES5 syntax (e.g. you write in TypeScript or CoffeeScript).\n\n| | Max. throughput (full event loop utilisation) | Concise, clear code (control-flow, data-flow and error-flow) | Max. support for Node.js dev/build tools | Max. support for JS envs (eg Node + browsers)\n|---|---|---|---|---|\n| Plain synchronous code | :heavy_exclamation_mark:<sup>[1]</sup> | :white_check_mark: | :white_check_mark: | :white_check_mark: |\n| Plain callbacks | :white_check_mark: | :heavy_exclamation_mark:<sup>[2]</sup> | :white_check_mark: | :white_check_mark: |\n| Callbacks + control-flow (e.g. [`async`](https://github.com/caolan/async)) | :white_check_mark: | :heavy_exclamation_mark:<sup>[3]</sup> | :white_check_mark: | :white_check_mark: |\n| Promises + control-flow (e.g. [`bluebird`](https://github.com/petkaantonov/bluebird/)) | :white_check_mark: | :heavy_exclamation_mark:<sup>[3]</sup> | :white_check_mark: | :white_check_mark: |\n| Coroutines with [`co`](https://github.com/visionmedia/co) | :white_check_mark: | :white_check_mark: | :heavy_exclamation_mark:<sup>[4]</sup> | :heavy_exclamation_mark:<sup>[5]</sup> |\n| Coroutines with `asyncawait` | :white_check_mark: | :white_check_mark: | :white_check_mark: | :heavy_exclamation_mark:<sup>[6]</sup> |\n\n**Footnotes:**\n<sup>**[1]**</sup> Each synchronous call blocks Node's event loop. All concurrent tasks are blocked, and the event loop sits idle, until the call completes.\n<sup>**[2]**</sup> Plain callbacks rapidly become unwieldy for complex asynchronous tasks. See [comparison](./comparison).\n<sup>**[3]**</sup> Whilst better than plain callbacks, these styles still produce longer and more complex code than synchronous or coroutine-based code. See [comparison](./comparison).\n<sup>**[4]**</sup> Some tools do not (yet) support ES6 generators, including [compile-to-JavaScript languages](https://github.com/jashkenas/coffee-script/wiki/List-of-languages-that-compile-to-JS) such as [TypeScript](http://www.typescriptlang.org/) and [CoffeeScript](http://coffeescript.org/).\n<sup>**[5]**</sup> [ES6](http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts) still has patchy browser support.\n<sup>**[6]**</sup> Strictly limited to Node.js environments (i.e. no browsers) due to the use of [`node-fibers`](https://github.com/laverdet/node-fibers).\n\n\n\n# 5. Performance\nHow well does `asyncawait` perform? The answer depends on what kinds of performance you care about. As a rough guide, compared with bare callbacks, expect your code to be 70% shorter with 66% less indents and run at 79% of the speed of bare callbacks. OK, so don't trust those numbers (which actually are [real](./comparison/README.md#comparison-summary)) but do check out the code in the [comparison](./comparison) folder, and do run your own [benchmarks](./comparison/benchmark.js).\n\n\n\n# 6. Quick Start\n\n### Installation\n`npm install asyncawait`\n\n### Async/Await 101\n`asyncawait` provides just two functions: `async()` and `await()`. You can reference these functions with the code:\n```javascript\nvar async = require('asyncawait/async');\nvar await = require('asyncawait/await');\n```\nUse `async` to declare a suspendable function. Inside a suspendable function, use `await` to suspend execution until an awaitable expression produces its result. Awaitable expressions typically involve performing asynchronous operations.\n\nNote the spacing after `async` and `await` in the examples. They are just plain functions, but the space makes them look more like keywords. Alternatively if you really want them to stand out, you could use names like `__await__` or `AWAIT`, or whatever works for you.\n\n### Basic Example\n```javascript\nvar async = require('asyncawait/async');\nvar await = require('asyncawait/await');\nvar Promise = require('bluebird');\nvar fs = Promise.promisifyAll(require('fs')); // adds Async() versions that return promises\nvar path = require('path');\nvar _ = require('lodash');\n\n/** Returns the number of files in the given directory. */\nvar countFiles = async (function (dir) {\n    var files = await (fs.readdirAsync(dir));\n    var paths = _.map(files, function (file) { return path.join(dir, file); });\n    var stats = await (_.map(paths, function (path) { return fs.statAsync(path); })); // parallel!\n    return _.filter(stats, function (stat) { return stat.isFile(); }).length;\n});\n\n// Give it a spin\ncountFiles(__dirname)\n    .then (function (num) { console.log('There are ' + num + ' files in ' + __dirname); })\n    .catch(function (err) { console.log('Something went wrong: ' + err); });\n```\n\nThe function `countFiles` returns the number of files in a given directory. To find this number, it must perform multiple asynchronous operations (using `fs.readdir` and `fs.stat`). `countFiles` is declared as a suspendable function by wrapping its definition inside `async(...)`. When `countFiles` is called with a `dir` string, it begins executing asynchronously and immediately returns a [promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) of a result. Internally, `countFiles` appears to have synchronous control flow. Each `await` call suspends execution until its argument produces a result, which then becomes the return value of the `await` call.\n\n### More Examples\nThe [examples](./examples) folder contains more examples. The [comparison](./comparison) folder also contains several examples, each coded in six different styles (using plain callbacks, using synchronous-only code, using the `async` library, using the `bluebird` library, using the `co` library, and using this `asyncawait` library). \n\n\n\n# 7. `async` in Depth: Suspendable Functions\nThe subsections below refer to the following code:\n```javascript\nvar suspendable = async (function defn(a, b) {\n\tassert(...) // may throw\n    var result = await (...)\n    return result;\n});\nvar suspendable2 = async.cps (function defn(a, b) {...});\nvar suspendable3 = async.thunk (function defn(a, b) {...});\nvar suspendable4 = async.result (function defn(a, b) {...});\n```\n\n### Accepting Arguments and Returning Values\nSuspendable functions may accept arguments. Calling `suspendable(1, 2)` will in turn call `defn(1, 2)`. Suspendable functions may be variadic. They report the same arity as their definition (i.e. `suspendable.length` and `defn.length` both return `2`).\n\nA suspendable function's definition may return with or without a value, or it may throw. Returning without a value is equivalent to returning `undefined`. The return value of the definition function becomes the result of the suspendable function (see [Obtaining Results from Suspendable Functions](#obtaining-results-from-suspendable-functions)). \n\n### Handling Errors and Exceptions\nA suspendable function's definition may throw exceptions directly or indirectly. If any of the `await` calls in `defn` asynchronously produces an error result, that error will be raised as an exception inside `defn`.\n\nWithin the definition of a suspendable function, exceptions may be handled using ordinary `try/catch` blocks. Any unhandled exception thrown from within `defn` will become the error result of `suspendable`.\n\n### Obtaining Results from Suspendable Functions\nA suspendable function executes asynchronously, so it cannot generally `return` its result (or `throw` an error) directly. By default, `async` produces suspendable functions that return promises. `suspendable` returns a promise that is fulfilled with `defn`'s return value, or rejected with `defn`'s exception. Other ways of communicating results/errors are also supported:\n\n- Returning a promise: `suspendable(1, 2).then(function (val) {...}, function (err) {...});`\n- Acceptng a node-style callback: `suspendable2(1, 2, function (err, val) {...});`\n- returning a lazily-executed thunk: `suspendable3(1, 2)(function (err, val) {...});`\n- returning the value directly: `try { var val = suspendable4(1, 2); } catch (err) {...}`\n\nNote that `suspendable4` can only be called from inside another suspendable function. Also, it is possible to create suspendable functions that comminucate results in multiple ways, such as both accepting a callback and returning a promise. You can use the [`async.mod`](#the-asyncmod-function) function to achieve this.\n\n### Preservation of `this` Context\nWhen a suspendable function is called, its `this` context is passed through to the call to its definition. For example, when `suspendable.call(myObj, 1, 2)` is executed, `defn` will be called with arguments `1` and `2` and a `this` value of `myObj`.\n\n### Creating and Using Asynchronous Iterators\nThe `async` function can be used to create asynchronous iterators. These are analogous to [ES6 iterators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/The_Iterator_protocol), except that the `next()` function is a suspendable function obeying all the rules described in this section. `async.iterable` creates an iterable which returns an asynchronous iterator whose `next()` function returns a promise of a `{value, done}` result.\n\nAsynchronous iterators have a `forEach()` method for iterating over their values. For more information, take a look at the [descendentFilePaths.js](./examples/descendentFilePaths.js) and [iteration.js](./examples/iteration.js) examples.\n\n### Eager versus Lazy Execution\nCalling a suspendable function such as `suspendable` starts its asynchronous execution immediately, as per the normal semantics of promises. In contrast, thunk-returning suspendable functions do not begin executing until a callback is passed to the thunk. Suspendable functions such as `suspendable3` thus have lazy semantics.\n\n### Nesting, Composition and Recursion\nSuspendable functions may be called in `await` expressions, since they return promises (or thunks or values) and are therefore [awaitable](#what-works-with-await). It follows that calls to suspendable functions may be arbitrarily nested and composed, and may be recursive.\n\n### The `async.mod` Function\nEvery variant of the `async` function (i.e. `async`, `async.cps`, `async.iterable`, etc) has a `mod` method that accepts an `options` object and returns another `async` function variant. The `options` object may contain any combination of the following four properties:\n\n```javascript\n{\n    returnValue: <string>; // Recognised values: 'none', 'promise', 'thunk', 'result'\n    acceptsCallback: <boolean>;\n    isIterable: <boolean>;\n    maxConcurrency: <number>; // Recognised values: falsy values and positive numbers\n}\n```\nOmitted properties will inherit their value from the `async` variant being modded. For example, the calls `async.mod({acceptsCallback:true})` and `async.cps.mod({returnValue:'promise'})` are equivalent. Both calls return an `async` function that may be used to create suspendable functions that both accept a callback and return a promise.\n\n\n\n# 8. `await` in Depth: Awaitable Expressions\nThe subsections below refer to the following code:\n```javascript\nvar suspendable = async (function () {\n\tvar promise1 = new Promise(.../* eventually produces the value 'p1' */);\n\tvar promise2 = new Promise(.../* eventually produces the value 'p2' */);\n    var thunk1 = function(callback) {.../* eventually produces the value 't1' */});\n    var thunk2 = function(callback) {.../* eventually produces the value 't2' */});\n    var thunk3 = ..., thunk4 = ...;\n\tvar r1 = await (promise1);\n\tvar r2 = await (thunk1);\n\tvar r3 = await (3.14);\n\tvar r4 = await ([promise2, 2, ['222', thunk2]]);\n\tvar r5 = await ({ t3: thunk3, t4: thunk4 });\n    return [r1, r2, r3, r4, r5];\n});\n```\n\n### What Works with `await`?\n`await` takes a single argument, which must be an awaitable expression. An awaitable expression may be any of the following:\n\n1. A [promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) (or any [`then`able object](http://wiki.commonjs.org/wiki/Promises/A)), as in `var r1 = await (promise1)`. The function `suspendable` will be suspended until `promise1` is settled. The promise's resolution value (`'p1'`) will become the `await` call's return value, and assigned to `r1`. If `promise1` is rejected, the rejection value will be thrown as an exception inside `suspendable`.\n2. A [thunk](https://github.com/visionmedia/co#thunks-vs-promises), as in `var r2 = await (thunk1)`. The thunk `thunk1` will be called immediately, and `suspendable` will be suspended until control is returned to the thunk's callback. The thunk's result (`'t1'`) will become the `await` call's return value, and assigned to `r2`. If `thunk1` returns an error, the error value will be thrown as an exception inside `suspendable`.\n3. A primitive value, such as a number, string or null, as in `var r3 = await (3.14)`. The `await` call will return immediately with the primitive value, in this case assigning the value `3.14` to `r3`.\n4. An array or [plain object](http://lodash.com/docs#isPlainObject), whose elements are all awaitables, as in `var r4 = await ([promise2, 2, ['222', thunk2]])`. Note this definition is recursive and allows nested object graphs. The function `suspendable` will be suspended until all contained awaitables (`promise2`, `2`, `'222'` and `thunk2`) have produced their value, at which time the `await` call will return a clone of the object graph with all awaitable expressions replaced by their results (`['p2', 2 ['222', 't2']]`). If any of the contained awaitables produces an error, the error value will be thrown as an exception in `suspendable`.\n\nNote that calling `await` with more than one argument (or with zero arguments) is equivalent to calling `await` with a single array containing all the arguments.\n\n### Obtaining Awaitable Versions of Node-Style APIs\nIn conventional Node.js code, asynchronous functions take a callback as their last parameter and don't return any value. Therefore, calls to these functions are **not awaitable**. However, awaitable versions may be obtained with relative ease using something like [`bluebird's`](https://github.com/petkaantonov/bluebird/) [`promisifyAll()`](https://github.com/petkaantonov/bluebird/blob/master/API.md#promisepromisifyallobject-target---object), or [`thunkify`](https://github.com/visionmedia/node-thunkify).\n\n### Maximising Concurrency\nA series of `await` calls are executed serially. For example, execution of `var r1 = await (promise1)` is completed before execution of `var r2 = await (thunk1)` begins.\n\nIn contrast, a single `await` call on an array or plain object processes all of the contained awaitables concurrently. For example, when the statement `var r5 = await ({ t3: thunk3, t4: thunk4 })` both `thunk3` and `thunk4` are called immediately, and their asynchronous tasks are executed concurrently. \n\nLibraries such as [lodash](http://lodash.com) and [underscore](http://underscorejs.org/) interoperate smoothly with `asyncawait`, for both producing arrays of concurrently executing tasks, and for consuming arrays of results.\n\n### Variations of `await`\nThere are several variations of the `await` function, with alternative behaviour when the awaitable expression is an array or plain object. Take a look at [awaitTop.js](./examples/awaitTop.js) for a usage example.\n\nThe `await.top(n)` variant accepts a number `n`, and resumes the suspendable function when the first `n` awaitable expressions contained in the awaitable array or plain object produce their value. The return value of the `await.top(n)` call is an array containing the fastest `n` results in the order they were resolved.\n\nThe `await.in` variant is like `await`, but does not clone the awaitable expression it recieves as an argument. The results of the contained awaitables are substituted in place into the original awaitable array or plain object, which becomes the return value of the `await` call.\n\n\n\n# 9. Recipes\n\n### Handling HTTP Routes with Express\nComing soon...\n\n### Asynchronous Testing with Mocha\nComing soon...\n\n\n\n# 10. API Reference\n\n### `function async(fn: Function) --> (...args) --> Promise`\nCreates a function that can be suspended at each asynchronous operation. `fn` contains the body of the suspendable function. `async` returns a function of the form `(...args) --> Promise`. Any arguments passed to this function are passed through to `fn`. The returned promise is resolved when `fn` returns, or rejected if `fn` throws.\n\n### `function async.cps(fn: Function) --> (...args, callback) --> void`\nVariant of `async` that produces a suspendable function that accepts a node-style callback and returns nothing. See [Obtaining Results from Suspendable Functions](#obtaining-results-from-suspendable-functions).\n\n### `function async.thunk(fn: Function) --> (...args) --> Thunk`\nVariant of `async` that produces a suspendable function that returns a thunk. See [Obtaining Results from Suspendable Functions](#obtaining-results-from-suspendable-functions).\n\n### `function async.result(fn: Function) --> (...args) --> any`\nVariant of `async` that produces a suspendable function that returns its result directly, but can only be called from inside another suspendable function. See [Obtaining Results from Suspendable Functions](#obtaining-results-from-suspendable-functions).\n\n### `function async.iterable(fn: Function) --> (...args) --> AsyncIterator`\nVariant of `async` that produces a function which returns an asynchronous iterator, whose `next()` method is a suspendable function that returns a promise. See [Creating and Using Asynchronous Iterators](#creating-and-using-asynchronous-iterators).\n\n### `function async.mod(options) --> AsyncFunction`\nEnables the creation of arbitrary variants of the `async` function. Accepts an `options` object and returns an `async` function variant. See [The `async.mod` Function](#the-asyncmod-function).\n\n### `function await(expr: Awaitable) --> Any`\nSuspends a suspendable function until the [awaitable](#what-works-with-await) expression `expr` produces a result. The result becomes the return value of the `await` call. If `expr` produces an error, then an exception is raised in the suspendable function.\n\n### `function await.top(n: number) --> (expr: Array|Object) --> Array`\nVariant of `await` whose result consists of the `n` fastest-resolving awaitables contained in its argument. See [Variations of `await`](#variations-of-await).\n\n### `function await.in(expr: Array|Object) --> Array|Object`\nVariant of `await` that returns the original array/object, rather than a cloned array/object, substituting the results of contained awaitables in-place. See [Variations of `await`](#variations-of-await).\n\n\n\n# 11. Acknowledgements\n`asyncawait` uses the following technologies:\n\n- [node-fibers](https://github.com/laverdet/node-fibers): This implementation of coroutines is unfortunately limited to Node.js. ES6 generators may be simpler, but fibers are more flexible and support a far broader space of design possibilities. It would be great if ES6 generators were this open and flexible.\n- [bluebird](https://github.com/petkaantonov/bluebird): this promise library is both a core component of `asyncawait` and a great source of inspiration for writing high-performance JavaScript code.\n- [TypeScript](http://www.typescriptlang.org/): `asyncawait` is written in TypeScript (look in the [src folder](./src)), and includes a [type declaration file](./src/typings/asyncawait/asyncawait.d.ts). TypeScript makes JavaScript development faster, less error-prone, more scaleable, and generally more pleasant.\n- [lodash](http://lodash.com/): underscore, but better.\n\n\n# 12. License\nCopyright (c) 2014-2015 Troy Gerwien\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/yortus/asyncawait.git"
  },
  "scripts": {
    "build": "tsc",
    "prepublish": "npm run build",
    "test": "mocha"
  },
  "version": "3.0.0"
}
